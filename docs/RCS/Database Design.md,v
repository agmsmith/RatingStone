head	1.17;
access;
symbols;
locks; strict;
comment	@# @;


1.17
date	2020.03.28.16.19.43;	author agmsmith;	state Exp;
branches;
next	1.16;

1.16
date	2020.03.28.13.18.21;	author agmsmith;	state Exp;
branches;
next	1.15;

1.15
date	2020.03.27.19.03.58;	author agmsmith;	state Exp;
branches;
next	1.14;

1.14
date	2020.03.26.20.25.45;	author agmsmith;	state Exp;
branches;
next	1.13;

1.13
date	2020.02.20.21.45.08;	author agmsmith;	state Exp;
branches;
next	1.12;

1.12
date	2020.02.07.15.28.32;	author agmsmith;	state Exp;
branches;
next	1.11;

1.11
date	2020.02.04.22.20.21;	author agmsmith;	state Exp;
branches;
next	1.10;

1.10
date	2020.02.03.22.33.40;	author agmsmith;	state Exp;
branches;
next	1.9;

1.9
date	2020.02.03.22.26.20;	author agmsmith;	state Exp;
branches;
next	1.8;

1.8
date	2020.02.02.22.15.24;	author agmsmith;	state Exp;
branches;
next	1.7;

1.7
date	2020.02.02.21.44.52;	author agmsmith;	state Exp;
branches;
next	1.6;

1.6
date	2020.01.31.21.54.25;	author agmsmith;	state Exp;
branches;
next	1.5;

1.5
date	2020.01.30.22.16.28;	author agmsmith;	state Exp;
branches;
next	1.4;

1.4
date	2020.01.30.15.45.39;	author agmsmith;	state Exp;
branches;
next	1.3;

1.3
date	2020.01.30.14.40.09;	author agmsmith;	state Exp;
branches;
next	1.2;

1.2
date	2020.01.29.22.52.13;	author agmsmith;	state Exp;
branches;
next	1.1;

1.1
date	2020.01.29.22.43.07;	author agmsmith;	state Exp;
branches;
next	;


desc
@Documenting the Rating Stone database design, and related classes.
@


1.17
log
@Split out AuxLink and AuxLedger records, making things simpler again.
@
text
@# The Rating Stone Reputation System Database

<SMALL>$Id: Database\040Design.md,v 1.16 2020/03/28 13:18:21 agmsmith Exp agmsmith $</SMALL>

## Basic Ideas

Because I'm thinking that someone could implement the reputation system as a
BlockChain ledger application, or as a federated collection of systems
exchanging records, the database is set up as a write once collection of object
records and link records.  Objects are the things the user can view and which
have ratings (posted messages, lists of things, other users).  Links implement
lists of things, connecting a pair of objects together, one being a parent or
container object (such as a list of book reviews) and the other being a child
object in that container (such as a book review object).  Usually rating points
are also transfered when you create a link (perhaps describing how much you
like that book review).  I'm using separate link records rather than parent
pointers in the objects so that an object can have multiple parents.

### Changing Things by Making New Objects

For example, if you want to edit some posted text, the system will create a
newer object (they all have datestamps) with the new text and a reference back
to the original text object record.  Then when displaying the original text, it
will search for newer versions and display that text instead.  But new
references (links) to the text (such as replies) will still point at the
original text record, since that has a more constant identity then possibly yet
more new text records.  Advanced users can view a list of all those text
records and see the change history.

Similarly when someone adds an item to a list, a link record will be added to
connect the list and the item.  To remove an item, the link record isn't
deleted, instead a new unlink record is created, referencing the original link
record.

Theoretically, when displaying the current state of things, you run through all
the records in chronological order, adding and removing objects and links from
the current state.  In practice, we cache things.  So an object record would
have a flag that marks it as deleted or amended, and a link record would
similarly be marked, and there can be cached forward references to more quickly
point out the record with the latest change.

### Single Table Inheritance

Because I don't want to have zillions of tables, and want to inherit
functionality for various related record types (generic object > text object >
book review object), we're using the Ruby on Rails ActiveRecord "[single table
inheritance](https://api.rubyonrails.org/classes/ActiveRecord/Inheritance.html)"
setup.  There will be one actual database table for objects and another one for
links between objects, both have the Rails magic "type" field in each row to
specify the particular subclass used for that row.

#### Reusing Generic Fields to Avoid Space Explosion

To avoid the common complaint about single table inheritance adding too many
fields for subclasses, we put some generic number and string fields into the
base class and reuse them differently for each subclass.  Subclasses give those
generic fields subclass-specific names by using the magic "alias_attribute"
ActiveRecord function.  So where the base may have a generic string1 and
string2 field, a User subclass could rename those as FullName and EMailAddress,
with "alias_attribute :full_name, :string1" and "alias_attribute
:email_address, :string2".  ActiveRecord will then automatically build queries
using the actual database field (string1, string2) names whenever we use the
subclass object.

### Direct References, Link Records, or Full Blown Lists

There's a design choice needed on making lists of things.  Should you make link
records between a main object and sub-objects that apply to it, or should you
have a second object as kind of a list header, and link the sub-objects to it?
For example, a Friends list.  You could link friends (LedgerUser records) to
the main user (another LedgerUser record) with specialised link_friend records.
Or you could make a LedgerListFriends object with a link to the main user, then
attach the friends to that with generic link records.

#### Design Choice - Faster

Direct links are faster for the database, but need a lot of custom link record
subclasses, but those are fairly cheap.  The list header method just needs to
give the list header a name and uses generic records, but requires more
database operations.  There's also a third option of putting the link reference
in the record as an id field, like friend_id, but that only works if you have
one friend (useful in other cases, like having only one creator).  We'll go
with the faster but more work custom link subclasses method, except for user
defined lists which will use the list header with a name technique, and plain
references where that makes sense.  If the number of subclasses gets too big,
this decision will have to be reconsidered.


## *LedgerBase*

The base class for persistent objects that the user may interact with.  There
is one database table for all objects of this class and subclasses.

* id The usual big (64 bit) integer unique record sequence number, which
  identifies the record/object.  There's an index of course to make finding a
  record by id number quick.  In the future we may use a GUID instead, or a
  pair of (id,server) if there are several federated servers run by different
  organisations.  Write-once.
* type string The name of the subclass to use for this object record.  "type"
  is the magic word Rails recognises to name a class and turn on single table
  inheritance mode.  Write-once.
* creator_id Identifies the user who created this record.  Never NULL; the root
  object is considered to have created itself.  Write-once.
* original_id Points to the original version of this record, or NULL if this is
  the original one.  When someone creates a link to the object, by default it's
  linked to by the original id.  The original record is still used to cache the
  rating points and other dynamic things, though the actual content (text in a
  Post for example) comes from the latest amended record (unless the user is
  looking for a specific version the object).  Happens to be write-once.
* amended_id Points to the latest version of this record, or NULL if this is
  not the original record.  Changed as needed.
* deleted boolean True if there is a LedgerDelete record that is currently
  deleting this record, otherwise false (record is alive).  A deleted object
  just shows a warning message to the user when an attempt is made to display
  it.  Rating points are accumulated as usual.  That way we can undelete this
  record if needed.  Changed as needed.
* current_down_points float  Changed as needed.
* current_meh_points float  Changed as needed.
* current_up_points float Changed as needed.  Number of rating points in each
  of the directions for this object.  This is the current total, including
  fading over time (recalculated at the beginning of the week in the awards
  ceremony) plus new ratings applied this week.  We keep the directions
  separate to improve statistical estimation of how accurate the rating is
  (just storing the net difference of 2 points isn't as meaningful as knowing
  you had 102 up and 100 down vs 3 up and 1 down), and use them as inputs to
  various different sorting algorithms.  Until someone redoes the statistical
  theory, we'll split meh points 50% to each of up and down.  But once we have
  better math, we can use meh directly.  When they have all faded away to close
  to zero (less than 0.01, equivalent to 3 years of fading one point) then the
  record can be garbage collected from the current database, freeing up
  storage.


### *LedgerDelete* < LedgerBase

Used for marking possibly multiple objects as deleted.  AuxLedger and AuxLink
records are used to associate this LedgerDelete with all the objects (both
LedgerBase object records and LinkBase link records) being deleted.  Undelete
is implemented by creating a LedgerUndelete record for the same target objects
(was too messy trying to delete a LedgerDelete; that is not supported).  Can
have several LedgerDelete and LedgerUndelete records affecting the same object;
only the latest unexpired one decides the target object's status.  So yes, if
enough time passes, the LedgerDelete will fade away and the targets will no
longer be deleted.  Though most often the targets will have faded away too by
that time.  Or we could have a policy of not garbage collecting LedgerDelete
and LedgerUndelete records.

* reason string  Reason for deletion.


### *LedgerUndelete* < LedgerBase

Undoes a LedgerDelete and is otherwise similar to it.  Besides being less
confusing than deleting a delete record, this lets us more easily find out who
is deleting a target.  Also, we can undelete a different set of things than
were deleted.

### *LedgerGivePermission* < LedgerBase

Gives permission for pending links to start working.  The links are specified
by AuxLink records.  Used for things like approving a request to join a group
(the request is a LinkBase record joining the person to the group).  To deny
permission, delete the unapproved link with LedgerDelete.  If you change your
mind, you can undelete the unapproved link.

* reason string  Reason for giving permission.


### *LedgerUser* < LedgerBase

Idenfities a particular user.

* User_id Points to a user's record in the separate Users database (see
  RailsTutorial) which has passwords, e-mail addresses and other private
  information.
* Elsewhere, the user is referenced by the record id number of the LedgerUser
  record.  Though for export or federated systems we'd need a GUID or an
  id+server pair.
* Points gained per week cached value.  Computed by considering various award
  records (such as e-mail verified, passport photo uploaded, had tea with the
  sysop, bought some bonus points) attached to the LedgerUser record by links.


### *LedgerMicropost* < LedgerBase

A micropost made by a user.  Contains some formatted text.  They can also
attach pictures and other media files (displayed in a grid, in order by link
creation date).  There can also be micropost replies, the micropost can be
placed in a category list to identify what the topic of the text is, have
rating points awarded to it, and so on.  This is the object the user interacts
with the most.  It is also usually visible to users and even external web
sites, unless permissions make it private.

* scribbles text The text written by the user for the micropost, in markdown
  UTF-8 format (we're using the kramdown dialect).  Length limited only by the
  number of points the user wants to spend (it's an unlimited Text not a String
  field).  Write-once.


### *LedgerMedia* < LedgerBase

A file uploaded by the user.  Usually some sort of media, like a picture or
video clip.  Can be attached to multiple microposts to make them more
interesting, and referenced by external web sites as well.  Byte size only
limited by the points the user wants to spend to upload it.  All kinds can
display a picture, which can be clicked on to get more detail or play it if it
is a video or audio file.

* Implicit ActiveStorage link stores the file.  May use CarrierWave if
  ActiveStorage URL policies are too annoying (too long, permanent links
  difficult).  Have functions for getting the file size, data type, URL, etc.


### *LedgerAwardCeremony* < LedgerBase

This record marks the time when (usually weekly) rating points are awarded.  We
perform the ceremony relative to planetary time, so the actual time between
ceremonies won't always be exactly 7 days and 0 seconds, due to the slowdown of
the earth's rotation and server downtime problems.  If you delete this record,
the ceremony is ignored and just about everything needs to be recalculated,
including award numbers for subsequent ceremonies and LinkBase records.
Currently deleting this kind of record is not implemented, so don't do it.

* award_number A count of the number of award ceremonies done up to and
  including this one.  In other words, a seqeunce counter starting at 1.  So if
  rating points were assigned at the beginning of time, before any awards, the
  faded value of the points after a particular award ceremony would be original
  points * (fade ** award_number).
* completed_at Time stamp for when the award ceremony was completed.  The start
  time is in the usual created_at time stamp for this record.  The web site is
  offline while the awards are being calculated.


### *LedgerBirthday* < LedgerBase

Identifies the birthday of a user.  Mostly an excuse to reuse the generic
timestamp field that LedgerAwardCeremony made necessary.

* birthday_at Date and time stamp of when the user was born, or first became
  independently operational.


## *LinkBase*

The base class for links of all kinds between pairs of objects.  There is one
database table for all instances of this class and subclasses.  The particular
subclass identifies what the link's purpose is (object A owns object B, object
A is a list header and B is in the list, etc).

* id The usual big (64 bit) integer unique record sequence number so that we
  can refer to the link record, currently only used by LedgerDelete/Undelete
  and LedgerGivePermission.  Write-once.
* type string  The name of the subclass to use for this record.  Write-once.
* parent_id Points to the LedgerBase object (or subclass) which is usually the
  main one in the association.  Never NULL.  Write-once.
* child_id Points to the child LedgerBase object (or subclass) which is usually
  the target one in the association (for example, parent_id could be a list
  header record, child_id is something in the list).  Never NULL.  Write-once.
* creator_id Identifies the LedgerUser who created this link.  Never NULL.
  Write-once.
* deleted boolean True if there is a LedgerDelete record that deletes this
  record, otherwise false (this record is alive).  Any rating points gained by
  the child object through this link vanish when it is deleted, as if they
  never were transfered.  However, the rating points spent by the user to make
  the link are not returned to the user (otherwise they could temporarily
  transfer points and someone else could spend more than they are allowed).
  Can undelete with LedgerUndelete, another good reason for keeping the rating
  points spent.  Changed as needed.
* pending boolean True if permission is currently denied.  The link record
  exists but it can't be traversed (sort of like being deleted) until someone
  gives permission.  The typical use case will be someone signing up for a
  discussion group by adding themselves as a member of the group (creating a
  LinkGroupMember between the group and their user record).  If the group's
  permissions allow linking, it goes into effect immediately.  If permission
  isn't automatic, then the new link is marked as pending.  Then one of the
  group moderators can approve the pending membership link by changing
  permission settings on the referenced objects or explicitly giving permission
  to this link with a LedgerGivePermission record.  The deleted boolean has
  priority over the pending one.  Changed as needed.
* rating_points_spent float The number of points spent on making this link by
  the creator.  Includes transaction fees (larger fees for storing more bytes
  and a base fee to avoid high speed trading problems).  Points after the fees
  will be given to the child and parent objects, the split decided by the user.
  Needed so that a reply to a post will boost the rating of both the post and
  the reply (so they both have longer lifetimes).  Write-once.
* rating_points_boost_child float The number of points used to boost the rating
  of the child object, equals spent minus fees and minus parent boost.  Over
  time they are considered to fade (the value in the database doesn't change,
  we just calculate the current faded value when needed), and when enough time
  has gone by, you can remove this link completely from the database.  If the
  child object no longer has any points, it can be deleted too, and so on.
  We'll probably do that as part of the weekly point updates - if the total is
  near zero (under 0.01, about 3 years of fading for one point), the link or
  object can be deleted.  Write-once.
* rating_points_boost_parent float The number of points to boost the rating of
  the parent.
* rating_direction char How the points from the creator are applied to the
  child and parent objects (both are in the same direction we assume), can be
  "U" for up, "D" for down or "M" for meh.  Write-once.
* award_number integer The week's award number when this record was created, 0
  if before any ceremonies have been done.  Lets us easily calculate the
  current faded value of the rating points.  This field can be recalculated by
  looking at this record's created_at date and cross referencing with all the
  LedgerAwardCeremony records up to the creation time.  Write-once.


### *LinkReply* < LinkBase

The child is a reply to the parent.  Usually both objects are LedgerMicropost.


### *LinkMedia* < LinkBase

The child is some sort of media which should be displayed when the parent is
shown.  Usually the parent is a LedgerMicropost and the child is a LedgerMedia
of some type.  We just treat them all as pictures and show them in a grid after
the text of the micropost (grid order determined by the order of datestamps of
these link records).  The user can click on individual ones to play them.


### *LinkPermission* < LinkBase

The parent is some LedgerObject, the child is some other LedgerObject that is
being granted permissions to access the parent.  Stock permissions are stored
in the LedgerObject itself (friends, owners, friends of friends, public, etc)
but for unusual special case objects being granted permission (like a
discussion group or a specific user), a LinkPermission is needed.  If there are
several LinkPermission records for the same parent/child object pair, they are
run through in reverse date of link creation (newest permission examined first)
until a permission decision is made.  The type of the permission granted is
specified by the link's subclass.  No permission check is needed to specify the
child of LinkPermission; you just need points and ownership rights to the
parent object to be able to creat a LinkPermission from your own object to any
LedgerUser object.

Possible subclasses are:

* LinkPermissionDeny - Target is not allowed to access the parent object.
* LinkPermissionView - Target can view the parent object.
* LinkPermissionReply - Target can link a new micropost object to the parent
  object as a reply.
* LinkPermissionWrite - Target can change the parent object (make new version).
* LinkPermissionOwner - Target has ownership permissions for the parent object.


## *AuxLink*

This database table and class is used for connecting LedgerBase records
(a LedgerDelete/Undelete or LedgerGivePermission) and LinkBase records.  Used
for deleting, undeleting, and giving permission to a LinkBase record.  The main
difference with LinkBase is that no rating points are involved.

* parent_id Points to a LedgerBase record doing something to a link.
* child_id Points to a LinkBase record being modified in some way.
* No time stamps or other fields, see the parent_id for the date etc.


## *AuxLedger*

Like AuxLink, but for connecting LedgerBase objects (usually a
LedgerDelete/Undelete) to child LedgerBase objects (things being deleted).

* parent_id Points to a LedgerBase record doing something to an object.
* child_id Points to a LedgerBase record being modified in some way.
* No time stamps or other fields, see the parent_id for the date etc.


## Generating the Database

Here are the rails command lines and edits needed to generate the database:

<PRE>rails generate model LedgerBase type:string
bool1:boolean date1:datetime number1:integer string1:string string2:string
text1:text creator:references original:references amended:references
deleted:boolean current_down_points:float current_meh_points:float
current_up_points:float

rails generate model LinkBase type:string
parent:references child:references creator:references deleted:boolean
pending:boolean rating_points_spent:float rating_points_boost_child:float
rating_points_boost_parent:float rating_direction:string award_number:integer

rails generate model AuxLedger parent:references child:references

rails generate model AuxLink parent:references child:references

# And for subclasses, do something like this:

rails generate model LedgerList --parent=LedgerBase

</PRE>

Combine and edit the migration files to have default values and better field
details like this:

<PRE>class CreateLedgerAndLinkBases < ActiveRecord::Migration[6.0]
  def change
    create_table :ledger_bases, force: false, comment: "Ledger objects base class and record.  Don't force: cascade deletes since this is a write-once ledger." do |t|
      t.string :type, default: "LedgerBase", comment: "Names the ActiveRecord subclass used to load this row, turning on single table inheritance."
      t.boolean :bool1, default: false, comment: "Generic boolean, defined by subclasses."
      t.integer :number1, default: 0, comment: "Generic number for counting things, defined by subclasses."
      t.string :string1, default: "", comment: "Generic string (up to 255 bytes), defined by subclasses."
      t.string :string2, default: "", comment: "Generic string (up to 255 bytes), defined by subclasses."
      t.text :text1, default: "", comment: "Generic text (lots of characters), defined by subclasses."
      t.references :creator, null: false, foreign_key: {to_table: :ledger_bases, name: "fk_rails_ledgercreator"}, comment: "Identifies the user who created this record."
      t.references :amended, null: true, foreign_key: {to_table: :ledger_bases, name: "fk_rails_ledgeramended"}, comment: "Points to the latest version of this record, or NULL if this is not the original record."
      t.boolean :deleted, default: false, comment: "True if there is a LedgerDelete record that is currently deleting this record, otherwise false (record is alive)."
      t.references :original, null: true, foreign_key: {to_table: :ledger_bases, name: "fk_rails_ledgeroriginal"}, comment: "Points to the original version of this record, or NULL if this is the original one."
      t.float :current_down_points, default: 0.0, comment: "Number of rating points in the down direction for this object. This is the current total, including fading over time (recalculated at the beginning of the week in the awards ceremony) plus new ratings applied this week."
      t.float :current_meh_points, default: 0.0, comment: "Number of rating points in the meh non-direction for this object. This is the current total, including fading over time (recalculated at the beginning of the week in the awards ceremony) plus new ratings applied this week."
      t.float :current_up_points, default: 0.0, comment: "Number of rating points in the up direction for this object. This is the current total, including fading over time (recalculated at the beginning of the week in the awards ceremony) plus new ratings applied this week."
      t.datetime :date1, null: true, comment: "Generic date and time from year 0 to year 9999, defined by subclasses."
      t.timestamps
    end

    add_index :ledger_bases, :string1
    add_index :ledger_bases, :string2
    add_index :ledger_bases, :number1

    create_table :link_bases, force: false, comment: "LinkBase base class and record for linking LedgerObjects together." do |t|
      t.string :type, default: "LinkBase", comment: "Names the ActiveRecord subclass used to load this row, turning on single table inheritance."
      t.references :parent, null: false, foreign_key: {to_table: :ledger_bases, name: "fk_rails_linkparent"}, comment: "Points to the LedgerBase object (or subclass) which is usually the main one in the association."
      t.references :child, null: false, foreign_key: {to_table: :ledger_bases, name: "fk_rails_linkchild"}, comment: "Points to the LedgerBase object (or subclass) which is the child in the association."
      t.references :creator, null: false, foreign_key: {to_table: :ledger_bases, name: "fk_rails_linkcreator"}, comment: "Identifies the User who created this link."
      t.boolean :deleted, default: false, comment: "True if there is a LedgerDelete record that deletes this record, otherwise false (this record is alive)."
      t.boolean :pending, default: false, comment: "True if permission is currently denied. The link record exists but it canâ€™t be traversed (sort of like being deleted) until someone gives permission."
      t.float :rating_points_spent, default: 0.0, comment: "The number of points spent on making this link by the creator."
      t.float :rating_points_boost_child, default: 0.0, comment: "The number of points used to boost the rating of the child object."
      t.float :rating_points_boost_parent, default: 0.0, comment: "The number of points used to boost the rating of the child object."
      t.string :rating_direction, default: "M", comment: "Use U for up, D for down or M for meh."
      t.integer :award_number, default: 0, comment: "The week's award number when this record was created, 0 if before time starts."
      t.timestamps
    end

    create_table :aux_links, force: false, comment: "AuxLink class and record for connecting LedgerObjects (usually LedgerDelete) to LinkBase records (usually links being deleted)." do |t|
      t.references :parent, null: false, foreign_key: {to_table: :ledger_bases, name: "fk_rails_auxlinkparent"}, comment: "Points to the LedgerBase object (or subclass) which has the delete or undelete or give permission order."
      t.references :child, null: false, foreign_key: {to_table: :link_bases, name: "fk_rails_auxlinkchild"}, comment: "Points to the child LinkBase object (or subclass) which is being modified by the parent."
    end

    create_table :aux_ledgers, force: false, comment: "AuxLedger class and record for connecting LedgerBase records (usually LedgerDelete) to other LedgerBase records (usually objects being deleted)." do |t|
      t.references :parent, null: false, foreign_key: {to_table: :ledger_bases, name: "fk_rails_auxledgerparent"}, comment: "Points to the LedgerBase object (or subclass) which has the delete or undelete order."
      t.references :child, null: false, foreign_key: {to_table: :ledger_bases, name: "fk_rails_auxledgerchild"}, comment: "Points to the child LedgerBase object (or subclass) which is being modified by the parent."
    end
  end
end
</PRE>


Flesh out link_base.rb with a few associations too:

<PRE>
class LinkBase < ApplicationRecord
  belongs_to :parent, class_name: :LedgerBase, optional: false
  belongs_to :child, class_name: :LedgerBase, optional: false
  belongs_to :creator, class_name: :LedgerBase, optional: false
end
</PRE>

Then do rails db:seed to set up the initial database contents.  One key step is
making the root LedgerBase object, with itself as its creator.

<PRE>ActiveRecord::Base.connection.execute(
  "INSERT into ledger_bases
    (id, string1, string2, text1, creator_id, created_at, updated_at)
  VALUES
    (0, 'Root LedgerBase Object', 'agmsmith@@ncf.ca', 'The special root object
    which we need to manually create with a creator id of itself.  Then initial
    system objects can be created with it as their creator.  AGMS20200206', 0,
    CURRENT_TIMESTAMP, CURRENT_TIMESTAMP);"
)
</PRE>


## Test Plan - A few Use Cases

A new user writes a message.  Another user replies to it.  First user edits
their message.  What does second user see?  First user replies to second user's
message.  First user deletes their original message.

A user adds some photos and videos to a message.  They are separate objects,
and need the expendature of rating points to be attached (more points are
required for a larger number of bytes).  What happens when they run out of
points?  Do they get attached to the message and show up when it is displayed?

First user sets up a small category tree and adds a message to a couple of
categories.  Second user navigates tree to see messages about their favourite
topic.

Weekly batch processing adds some reputation points to first and second user.
First user likes second user, awarding some up points, declaring their
appreciation.  Second user awards some down points to first user, declaring
their disgust.  What are their total points?  Another weekly batch run happens.
What are their points?

<PRE>
$Header: /home/agmsmith/Programming/Rating\040Stone/docs/RCS/Database\040Design.md,v 1.16 2020/03/28 13:18:21 agmsmith Exp agmsmith $

$Log: Database\040Design.md,v $
Revision 1.16  2020/03/28 13:18:21  agmsmith
Typos.

Revision 1.15  2020/03/27 19:03:58  agmsmith
Minor typos fixed.

Revision 1.14  2020/03/26 20:25:45  agmsmith
Rethought deleting and permissions.

Revision 1.13  2020/02/20 21:45:08  agmsmith
Fix typos after proofreading.

Revision 1.12  2020/02/07 15:28:32  agmsmith
Mention initialising the root object in the database.

Revision 1.11  2020/02/04 22:20:21  agmsmith
Proof reading pass done.  Also added list design choices.

Revision 1.10  2020/02/03 22:33:40  agmsmith
Fix up formatting in kramdown for preformatted code.

Revision 1.9  2020/02/03 22:26:20  agmsmith
Added command lines needed to generate the database.

Revision 1.8  2020/02/02 22:15:24  agmsmith
Added permissions records.

Revision 1.7  2020/02/02 21:44:52  agmsmith
After some experiments, decided to use floating point rating points.

Revision 1.6  2020/01/31 21:54:25  agmsmith
Work in progress adding fields and descriptions, worrying about deleting.

Revision 1.5  2020/01/30 22:16:28  agmsmith
Starting to add fields to the base object record.

Revision 1.4  2020/01/30 15:45:39  agmsmith
Explain the ledger write-once system and single table inheritance.

Revision 1.3  2020/01/30 14:40:09  agmsmith
Writing continues, work in progress.

Revision 1.2  2020/01/29 22:52:13  agmsmith
Fixed up formatting of RCS log and version number.

Revision 1.1  2020/01/29 22:43:07  agmsmith
Initial revision
</PRE>
@


1.16
log
@Typos.
@
text
@d3 1
a3 1
<SMALL>$Id: Database\040Design.md,v 1.15 2020/03/27 19:03:58 agmsmith Exp agmsmith $</SMALL>
d136 11
a146 11
Used for marking possibly multiple objects as deleted.  LinkDeleteChildObject
and LinkBreakChildLink records are used to associate this LedgerDelete with all
the objects (both LedgerBase object records and LinkBase link records) being
deleted.  Undelete is implemented by creating a LedgerUndelete record for the
same target objects (was too messy trying to delete a LedgerDelete; that is not
supported).  Can have several LedgerDelete and LedgerUndelete records affecting
the same object; only the latest unexpired one decides the target object's
status.  So yes, if enough time passes, the LedgerDelete will fade away and the
targets will no longer be deleted.  Though most often the targets will have
faded away too by that time.  Or we could have a policy of not garbage
collecting LedgerDelete and LedgerUndelete records.
d160 5
a164 5
Gives permission for a pending link to start working.  Used for things like
approving a request to join a group (the request is a LinkBase subclass).  To
deny permission, delete the unapproved link.  If you change your mind, you can
undelete the unapproved link.  Uses LinkPermission records to identify the
approved links.
d256 3
a258 7
* ledger1_id Used by LinkBaseObject subclasses for child pointers to
  LedgerBase objects.  Will only be NULL for LinkBaseLink subclasses.
  Write-once.
* link1_id Used by LinkBaseLink subclasses for child pointers to other LinkBase
  records.  Will only be NULL for LinkBaseObject subclasses.  Unfortunately
  can't be combined with ledger_id though they are mutually exclusive in use,
  since we need to have a different foreign key index on each one.  Write-once.
d271 2
a272 4
  gives permission (by changing permission settings on the referenced objects
  or explicitly giving permission to this link with a LedgerGivePermission
  record).  The typical use case will be someone signing up for a discussion
  group by adding themselves as a member of the group (creating a
d276 4
a279 4
  group moderators can approve the pending membership link by adding a
  LedgerGivePermission record attached to the link or by changing the group's
  overall permissions.  The deleted boolean has priority over the pending one.
  Changed as needed.
d307 1
a307 41
### *LinkBaseObject* < LinkBase

Abstract class where the child is a LedgerBase record.

* child_object_id Points to the LedgerBase object (or subclass) which is the
  other one in the association.  Not NULL, except always NULL in LinkBaseLink
  records.


### *LinkBaseLink* < LinkBase

Abstract class where the child is a LinkBase record.  Mostly used for
LedgerDelete when we remove something from a list by breaking a link.

* child_link_id Points to the LinkBase object (or subclass) which is the other
  one in the association.  Not NULL, except always NULL in LinkBaseObject
  records.


### *LinkDeleteChildObject* < LinkBaseObject

Identifies an object (not link) to be deleted, for use with LedgerDelete and
LedgerUndelete.  Parent is the LedgerDelete record, child is the LedgerBase
record being deleted or undeleted.


### *LinkBreakChildLink* < LinkBaseLink

Identifies a link (not object) to be broken or restored, for use with
LedgerDelete and LedgerUndelete.  Parent is the LedgerDelete record, child is
the LinkBase record being deleted or undeleted.


### *LinkGivePermissionLink* < LinkBaseLink

Identifies a link (not object) to be given permission.  For use with
LedgerGivePermission.  Parent is the LedgerGivePermission record, child is
the LinkBase record being given permission to start working.


### *LinkReply* < LinkBaseObject
d312 1
a312 1
### *LinkMedia* < LinkBaseObject
d321 1
a321 1
### *LinkPermission* < LinkBaseObject
d346 22
d375 9
a383 2
deleted:references ledger1:references
current_down_points:float current_meh_points:float current_up_points:float</PRE>
d385 1
a385 1
Edit the migration file to have default values like this:
d387 10
a396 1
<PRE>class CreateLedgerBases < ActiveRecord::Migration[6.0]
d398 2
a399 2
    create_table :ledger_bases, force: false, comment: "Ledger objects base class and record.  Don't force: cascade deletes since it is a write-once ledger." do |t|
      t.string :type, default: "LedgerBase", comment: "Names the ActiveRecord subclass used to load this row."
a400 1
      t.datetime :date1, default: DateTime.new(1,1,1,0,0,0), comment: "Generic date and time from year 0 to year 9999, defined by subclasses."
d406 2
d409 4
a412 6
      t.references :amended, null: true, foreign_key: {to_table: :ledger_bases, name: "fk_rails_ledgeramended"}, comment: "Points to the latest version of this record, or NULL if this is not the original record."
      t.references :deleted, null: true, foreign_key: {to_table: :ledger_bases, name: "fk_rails_ledgerdeleted"}, comment: "Points to one of the LedgerDelete records that is currently deleting this record, otherwise NULL (record is alive)."
      t.references :ledger1, null: true, foreign_key: {to_table: :ledger_bases, name: "fk_rails_ledger1"}, comment: "Generic reference to some other LedgerBase record, can be NULL, defined by subclasses."
      t.float :current_down_points, default: 0.0
      t.float :current_meh_points, default: 0.0
      t.float :current_up_points, default: 0.0
a414 10
  end
end</PRE>

In ledger_base.rb:
<PRE>
  has_many :link_downs, class_name: :LinkBase, foreign_key: :parent_id
  has_many :descendants, through: :link_downs, source: :child
  has_many :link_ups, class_name: :LinkBase, foreign_key: :child_id
  has_many :ancestors, through: :link_ups, source: :parent
</PRE>
d416 3
a418 1
Then make the LinkBase object / record:
a419 6
<PRE>rails generate model LinkBase type:string
parent:references child:references creator:references deleted:references
rating_points:float rating_direction:string award_number:integer</PRE>

<PRE>class CreateLinkBases < ActiveRecord::Migration[6.0]
  def change
d421 1
a421 1
      t.string :type, default: "LinkBase", comment: "Names the ActiveRecord subclass used to load this row."
d423 1
a423 1
      t.references :child, null: false, foreign_key: {to_table: :ledger_bases, name: "fk_rails_linkchild"}, comment: "Points to the LedgerBase object (or subclass) which is the other one in the association."
d425 2
a426 1
      t.references :deleted, null: true, foreign_key: {to_table: :ledger_bases, name: "fk_rails_linkdeleted"}, comment: "Points to one of the LedgerUnlink or LedgerDelete records that deleted this record, otherwise NULL (this record is alive)."
d428 2
a429 1
      t.float :rating_points_boost, default: 0.0, comment: "The number of points used to boost the rating of the child object."
d434 10
d445 5
a449 1
end</PRE>
a450 1
In link_base.rb add:
d452 1
d455 2
a458 10
Then add the LinkBase reference field in the LedgerBase record:

<PRE>rails generate migration AddLink1ToLedgerBase link1:references:index</PRE>

<PRE>class AddLink1ToLedgerBase < ActiveRecord::Migration[6.0]
  def change
    add_reference :ledger_bases, :link1, null: true, foreign_key: {to_table: :link_bases, name: "fk_rails_ledgerlink1"}, comment: "Points to a generic LinkBase object (or subclass)."
  end
end</PRE>

d462 11
d496 1
a496 1
$Header: /home/agmsmith/Programming/Rating\040Stone/docs/RCS/Database\040Design.md,v 1.15 2020/03/27 19:03:58 agmsmith Exp agmsmith $
d499 3
@


1.15
log
@Minor typos fixed.
@
text
@d3 1
a3 1
<SMALL>$Id: Database\040Design.md,v 1.14 2020/03/26 20:25:45 agmsmith Exp agmsmith $</SMALL>
d256 4
a259 3
* ledger_id Used by LinkBaseObject subclasses for child pointers to LedgerBase
  objects.  Will only be NULL for LinkBaseLink subclasses.  Write-once.
* link_id Used by LinkBaseLink subclasses for child pointers to other LinkBase
d500 1
a500 1
$Header: /home/agmsmith/Programming/Rating\040Stone/docs/RCS/Database\040Design.md,v 1.14 2020/03/26 20:25:45 agmsmith Exp agmsmith $
d503 3
@


1.14
log
@Rethought deleting and permissions.
@
text
@d3 1
a3 1
<SMALL>$Id: Database\040Design.md,v 1.13 2020/02/20 21:45:08 agmsmith Exp agmsmith $</SMALL>
d25 4
a28 4
references (links) to the text will still point at the original text record,
since that has a more constant identity then possibly yet more new text
records.  Of course, advanced users can view a list of all those text records
and see the change history.
d84 1
a84 1
defined lists which will use the list header with a name technique.  And plain
d163 2
a164 1
undelete the unapproved link.
d196 2
a197 1
  number of points the user wants to spend (it's a Text not a String field).
d252 1
a252 1
  and the related LinkBreakChildLink records.  Write-once.
d499 1
a499 1
$Header: /home/agmsmith/Programming/Rating\040Stone/docs/RCS/Database\040Design.md,v 1.13 2020/02/20 21:45:08 agmsmith Exp agmsmith $
d502 3
@


1.13
log
@Fix typos after proofreading.
@
text
@d3 1
a3 1
<SMALL>$Id: Database\040Design.md,v 1.12 2020/02/07 15:28:32 agmsmith Exp agmsmith $</SMALL>
d7 1
a7 1
Because I'm thinking someone could implement the reputation system as a
d10 1
a10 1
records and link records.  Objects are the things the user can view and they
d14 3
a16 3
object now in that container (such as a book review object).  Usually rating
points are also transfered when you create a link (perhaps describing how much
you like that book review).  I'm using separate links rather than parent
d49 2
a50 2
links, both have a "type" field in each row to specify the particular subclass
used for that row.
d78 9
a86 9
subclasses.  The list header method just needs to give the list header a name
and uses generic records, but requires more database operations.  There's also
a third option of putting the link reference in the record as an id field, like
friend_id, but that only works if you have one friend (useful in other cases,
like having only one creator).  We'll go with the faster but more work custom
link subclasses method, except for user defined lists which will use the list
header with a name technique.  And plain references where that makes sense.  If
the number of subclasses gets too big, this decision will have to be
reconsidered.
d99 3
a101 2
* type string The name of the subclass to use for this object record.
  Write-once.
d112 5
a116 5
* deleted_id Points to one of the LedgerDelete records that is currently
  deleting this record, otherwise NULL (record is alive).  Deleted records just
  show a warning message to the user when an attempt is made to display this
  object.  Rating points are accumulated as usual.  That way we can undelete
  this record if needed.  Changed as needed.
d130 3
a132 1
  record can be deleted from the current database, freeing up storage.
d136 28
a163 16
Used for marking possibly multiple objects as deleted or killed.  LinkDelChild
records are used to associate this LedgerDelete with all the objects being
deleted.  Undelete is implemented by creating a new LedgerDelete record to kill
the original LedgerDelete record, repeat as needed to redelete and so on.  We
don't support, or even want to think about having a LedgerDelete delete itself.
Can have several LedgerDelete records deleting the same object; need to kill
all those LedgerDelete records to undelete that object.

* unlink_too boolean True if the links to the object (those where LinkBase
  child_id points to the deleted object) are deleted too (removing it from all
  lists), false if just the object is deleted.  This flag is ignored when
  deleting a LedgerDelete record - all associated links and objects are updated
  recursively.


### *LedgerUnlink* < LedgerBase
d165 1
a165 4
Breaks a link, used for removing an object from a list.  You can undo an unlink
by deleting this LedgerUnlink object.

* link_id Which LinkBase object to mark as deleted.
d185 11
a195 9
A micropost made by a user.  Contains some text in UTF-8 markdown format.  They
can also attach pictures and other media files.  There can also be micropost
replies, the micropost can be placed in a category list to identify what the
topic of the text is, have rating points awarded to it, and so on.  This is the
object the user interacts with the most.  It is also usually visible to users
and even external web sites, unless permissions make it private.

* content Text for the micropost.  Length limited only by the number of points
  the user wants to spend.
d201 9
a209 7
video clip.  Can be attached to microposts to make them more interesting, and
referenced by external web sites as well.  Byte size only limited by the points
the user wants to spend to upload it.  All kinds can display a picture, which
can be clicked on to get more detail or play it if it is a video or audio file.

* Implicit ActiveStorage link stores the file.  Have functions for getting the
  file size, data type, URL, etc.
d217 4
a220 4
the earth's rotation.  If you delete this record, the ceremony is ignored and
just about everything needs to be recalculated, including award numbers for
subsequent ceremonies and LinkBase records.  Currently deleting this kind of
record is not implemented, so don't do it.
a240 21
### *LedgerPermissions* < LedgerBase

Specifies the permissions needed to access the LedgerObject this record is
linked to via LinkPermission.  There is a list or even a subtree linked to this
record specifying a bunch of users in some way (friends of friends etc), as
specifed by the link record type.  Often this will be a discussion group list.
There can be several LedgerPermissions records attached to the same object,
they are applied in chronological order of link created dates until a decision
is made.  A LedgerPermissions record can be shared between several objects too,
such as a default permission for a discussion group applying to all microposts
and replies in the group.

* present_permission char Has "N" to prohibit the listed users from accessing
  the object, "R" to allow only read access, "L" to allow link creation access
  too (adding a micropost to your own list), "W" to allow write access too
  (writing replies, effectively adding a link to the micropost), "A" to add
  amending and deleting access, "I" to inherit permissions from a later
  permission record ("I" could also be thought to mean ignore).
* absent_permission char Same letter codes, but apply to users NOT listed.


d244 1
a244 1
database table for all objects of this class and subclasses.  The particular
d249 3
a251 2
  can refer to the link record,  only explicitly used by LedgerUnlink.
* type string The name of the subclass to use for this object record.
d253 30
a282 13
  main one in the association.  Never NULL.
* child_id Points to the LedgerBase object (or subclass) which is the other one
  in the association.  Never NULL.
* creator_id Identifies the User who created this link.  Never NULL.
* deleted_id Points to one of the LedgerUnlink or LedgerDelete records that
  deleted this record, otherwise NULL (this record is alive).  If this record
  is deleted, the link it made is considered to not exist any more.  Any rating
  points gained by that object through the link vanish, as if they never were
  transfered.  However, the rating points spent by the user to make the link
  are not returned to the user (otherwise they could temporarily transfer
  points and someone else could spend more than they are allowed).  Can
  undelete by deleting the LedgerUnlink or LedgerDelete, another good reason
  for keeping the rating points spent.
d284 16
a299 10
  the creator, including transaction fees (larger fees for storing more bytes
  and a base fee to avoid high speed trading problems).
* rating_points_boost float The number of points used to boost the rating of
  the child object, equals spent minus fees.  Over time they are considered to
  fade (the value in the database doesn't change, we just calculate the current
  faded value when needed), and when enough time has gone by, you can remove
  this link completely from the database.  If the child object no longer has
  any points, it can be deleted too, and so on.  We'll probably do that as part
  of the weekly point updates - if the total is near zero (under 0.01, about 3
  years of fading for one point), the link or object can be deleted.
d301 10
a310 6
  child object, can be "U" for up, "D" for down or "M" for meh.
* award_number The week's award number when this record was created, 0 if
  before any ceremonies have been done.  Lets us easily calculate the current
  faded value of the rating points.  This field can be recalculated by looking
  at this record's created_at date and cross referencing with all the undeleted
  LedgerAwardCeremony records.
d312 1
d314 3
a316 1
### *LinkDelChild* < LinkBase
a317 4
Identifies an object to be deleted, for use with LedgerDelete.  Parent is the
LedgerDelete record, child is one of the objects being deleted.  If this
LinkDelChild object is deleted, then the LedgerDelete operation is modified to
not include the child.
d319 1
d321 30
a350 1
### *LinkReply* < LinkBase
d355 1
a355 1
### *LinkMedia* < LinkBase
d360 2
a361 1
the text of the micropost.  The user can click on individual ones to play them.
d364 1
a364 1
### *LinkPermission* < LinkBase
d366 21
a386 4
The parent is some LedgerObject, the child is a LedgerPermissions record that
applies to the parent.  If there are several LinkPermission records for the
same parent object, they are run through in increasing date of link creation
until a permission decision is made.
d497 1
a497 1
$Header: /home/agmsmith/Programming/Rating\040Stone/docs/RCS/Database\040Design.md,v 1.12 2020/02/07 15:28:32 agmsmith Exp agmsmith $
d500 3
@


1.12
log
@Mention initialising the root object in the database.
@
text
@d3 1
a3 1
<SMALL>$Id: Database\040Design.md,v 1.11 2020/02/04 22:20:21 agmsmith Exp agmsmith $</SMALL>
d16 2
a17 1
you like that book review).
d84 3
a86 1
header with a name technique.  And plain references where that makes sense.
d102 1
a102 1
  user is considered to have created themself.  Write-once.
d106 1
a106 1
  rating points and other dyanmic things, though the actual content (text in a
d121 9
a129 9
  ceremony) plus new ratings applied this week.  We keep the directions seprate
  to improve statistical estimation of how accurate the rating is (just storing
  the net difference of 2 points isn't as meaningful as knowing you had 102 up
  and 100 down vs 3 up and 1 down), and use them as inputs to various different
  sorting algorithms.  Until someone redoes the statistical theory, we'll split
  meh points 50% to each of up and down.  But once we have better math, we can
  use meh directly.  When they have all faded away to close to zero (less than
  0.01, equivalent to 3 years of fading one point) then the record can be
  deleted from the current database, freeing up storage.
d212 2
a213 1
  time is in the usual created_at time stamp for this record.
d427 1
a427 1
$Header: /home/agmsmith/Programming/Rating\040Stone/docs/RCS/Database\040Design.md,v 1.11 2020/02/04 22:20:21 agmsmith Exp agmsmith $
d430 3
@


1.11
log
@Proof reading pass done.  Also added list design choices.
@
text
@d3 1
a3 1
<SMALL>$Id: Database\040Design.md,v 1.10 2020/02/03 22:33:40 agmsmith Exp agmsmith $</SMALL>
d397 3
d423 1
a423 1
$Header: /home/agmsmith/Programming/Rating\040Stone/docs/RCS/Database\040Design.md,v 1.10 2020/02/03 22:33:40 agmsmith Exp agmsmith $
d426 3
@


1.10
log
@Fix up formatting in kramdown for preformatted code.
@
text
@d3 3
a5 1
<SMALL>$Id: Database\040Design.md,v 1.9 2020/02/03 22:26:20 agmsmith Exp agmsmith $</SMALL>
d18 2
d21 1
a21 1
later object (they all have datestamps) with the new text and a reference back
d31 2
a32 2
deleted, instead a new link kill record is created, referencing the same two
objects.
d41 2
d51 2
d64 21
d105 1
a105 1
  looking for a specific version the object).
d107 1
a107 1
  not the original record.
d110 15
a124 15
  show a message to the user when an attempt is made to display this object.
  Rating points are accumulated as usual.  That way we can undelete this record
  if needed.
* current_down_points float
* current_meh_points float
* current_up_points float Number of rating points in each of the directions for
  this object.  This is the current total, including fading over time
  (recalculated at the beginning of the week in the awards ceremony) plus new
  ratings applied this week.  We keep the directions seprate to improve
  statistical estimation of how accurate the rating is (just storing the net
  difference of 2 points isn't as meaningful as knowing you had 102 up and 100
  down vs 3 up and 1 down), and use them as inputs to various different sorting
  algorithms.  Until someone redoes the statistical theory, we'll split meh
  points 50% to each of up and down.  But once we have better math, we can use
  meh directly.  When they have all faded away to close to zero (less than
a127 1

d205 1
a205 1
  rating points were used at the beginning of time, before any awards, the
d207 1
a207 1
  points * (fade ** AwardNumber).
d237 2
a238 2
  amending and deleting access, "I" to inherit permissions from some other
  permission record.
d263 3
a265 1
  points and someone else could spend more than they are allowed).
d289 3
a291 2
LedgerDelete record, child is the object being deleted.  If this link object is
deleted, then the LedgerDelete operation is modified to not include child.
d320 2
a321 2
bool1:boolean date1:datetime number1:integer string1:string text1:text
creator:references original:references amended:references
d334 2
a335 1
      t.string :string1, default: "", comment: "Generic string (up to 255 characters), defined by subclasses."
d420 1
a420 1
$Header: /home/agmsmith/Programming/Rating\040Stone/docs/RCS/Database\040Design.md,v 1.9 2020/02/03 22:26:20 agmsmith Exp agmsmith $
d423 3
@


1.9
log
@Added command lines needed to generate the database.
@
text
@d3 1
a3 1
<SMALL>$Id: Database\040Design.md,v 1.8 2020/02/02 22:15:24 agmsmith Exp agmsmith $</SMALL>
d296 1
a296 1
class CreateLedgerBases < ActiveRecord::Migration[6.0]
d316 1
a316 1
end
d319 1
d324 1
d326 1
d332 1
a332 1
class CreateLinkBases < ActiveRecord::Migration[6.0]
d347 1
a347 1
end
d350 1
d353 1
a353 1

d359 1
a359 1
class AddLink1ToLedgerBase < ActiveRecord::Migration[6.0]
d363 1
a363 1
end
d388 1
a388 1
$Header: /home/agmsmith/Programming/Rating\040Stone/docs/RCS/Database\040Design.md,v 1.8 2020/02/02 22:15:24 agmsmith Exp agmsmith $
d391 3
@


1.8
log
@Added permissions records.
@
text
@d3 1
a3 1
<SMALL>$Id: Database\040Design.md,v 1.7 2020/02/02 21:44:52 agmsmith Exp agmsmith $</SMALL>
d57 2
a58 1
## LedgerBase
d68 1
a70 5
* permissions_id Points to the most recent permissions record for this object.
  NULL if everybody is allowed to read it.  Often this will point to a user's
  settings list which contains the default permissions.  For discussion groups,
  it will point to the permission in the group's settings.  Updated when a new
  permissions record is linked to this object.
d100 9
a108 9
**LedgerDelete** < LedgerBase
: Used for marking possibly multiple objects as deleted or killed.
  LinkDelChild records are used to associate this LedgerDelete with all the
  objects being deleted.  Undelete is implemented by creating a new
  LedgerDelete record to kill the original LedgerDelete record, repeat as
  needed to redelete and so on.  We don't support, or even want to think about
  having a LedgerDelete delete itself.  Can have several LedgerDelete records
  deleting the same object; need to kill all those LedgerDelete records to
  undelete that object.
d117 4
a120 3
**LedgerUnlink** < LedgerBase
: Breaks a link, used for removing an object from a list.  You can undo an
  unlink by deleting this LedgerUnlink object.
d125 3
a127 2
**LedgerUser** < LedgerBase
: Idenfities a particular user.
d140 8
a147 8
**LedgerMicropost** < LedgerBase
: A micropost made by a user.  Contains some text in UTF-8 markdown format.
  They can also attach pictures and other media files.  There can also be
  micropost replies, the micropost can be placed in a category list to identify
  what the topic of the text is, have rating points awarded to it, and so on.
  This is the object the user interacts with the most.  It is also usually
  visible to users and even external web sites, unless permissions make it
  private.
d153 7
a159 7
**LedgerMedia** < LedgerBase
: A file uploaded by the user.  Usually some sort of media, like a picture or
  video clip.  Can be attached to microposts to make them more interesting, and
  referenced by external web sites as well.  Byte size only limited by the
  points the user wants to spend to upload it.  All kinds can display a
  picture, which can be clicked on to get more detail or play it if it is a
  video or audio file.
d165 9
a173 8
**LedgerAwardCeremony** < LedgerBase
: This record marks the time when (usually weekly) rating points are awarded.
  We perform the ceremony relative to planetary time, so the actual time
  between ceremonies won't always be exactly 7 days and 0 seconds, due to the
  slowdown of the earth's rotation.  If you delete this record, the ceremony is
  ignored and just about everything needs to be recalculated, including award
  numbers for subsequent ceremonies and LinkBase records.  Currently deleting
  this kind of record is not implemented, so don't do it.
d184 4
a187 3
**LedgerBirthday** < LedgerBase
: Identifies the birthday of a user.  Mostly an excuse to reuse the generic
  timestamp field that LedgerAwardCeremony made necessary.
d193 11
a203 10
**LedgerPermissions** < LedgerBase
: Specifies the permissions needed to access the LedgerObject this record is
  linked to via LinkPermission.  There is a list or even a subtree linked to
  this record specifying a bunch of users in some way (friends of friends etc),
  as specifed by the link record type.  Often this will be a discussion group
  list.  There can be several LedgerPermissions records attached to the same
  object, they are applied in chronological order of link created dates until a
  decision is made.  A LedgerPermissions record can be shared between several
  objects too, such as a default permission for a discussion group applying to
  all microposts and replies in the group.
d214 2
a215 1
## LinkBase
d219 1
a219 4
A is a list header and B is in the list, etc).  Theoretically we don't need
subclasses and could determine the use by examining the object types, but
subclasses and having a type name field in the record is more convenient for
database debugging and sanity checks.
d236 11
a246 8
* rating_points float The number of points spent on making this link by the
  creator.  Over time they are considered to fade (the value in the database
  doesn't change, we just calculate the current faded value when needed), and
  when enough time has gone by, you can remove this link completely from the
  database.  If the child object no longer has any points, it can be deleted
  too, and so on.  We'll probably do that as part of the weekly point updates -
  if the total is near zero (under 0.01, about 3 years of fading for one
  point), the link or object can be deleted.
d256 1
a256 8
**LinkDelChild** < LinkBase
: Identifies an object to be deleted, for use with LedgerDelete.  Parent is the
  LedgerDelete record, child is the object being deleted.  If this link object
  is deleted, then the LedgerDelete operation is modified to not include child.


**LinkReply** < LinkBase
: The child is a reply to the parent.  Usually both objects are LedgerMicropost.
d258 102
a359 14

**LinkMedia** < LinkBase
: The child is some sort of media which should be displayed when the parent is
  shown.  Usually the parent is a LedgerMicropost and the child is a
  LedgerMedia of some type.  We just treat them all as pictures and show them
  in a grid after the text of the micropost.  The user can click on individual
  ones to play them.


**LinkPermission** < LinkBase
: The parent is some LedgerObject, the child is a LedgerPermissions record that
  applies to the parent.  If there are several LinkPermission records for the
  same parent object, they are run through in increasing date of link creation
  until a permission decision is made.
d384 1
a384 1
$Header: /home/agmsmith/Programming/Rating\040Stone/docs/RCS/Database\040Design.md,v 1.7 2020/02/02 21:44:52 agmsmith Exp agmsmith $
d387 3
@


1.7
log
@After some experiments, decided to use floating point rating points.
@
text
@d3 1
a3 1
<SMALL>$Id: Database\040Design.md,v 1.6 2020/01/31 21:54:25 agmsmith Exp agmsmith $</SMALL>
d102 1
d119 1
d126 1
d140 1
d153 1
d165 1
d183 1
d192 20
d252 1
d258 1
d262 1
d271 7
d300 1
a300 1
$Header: /home/agmsmith/Programming/Rating\040Stone/docs/RCS/Database\040Design.md,v 1.6 2020/01/31 21:54:25 agmsmith Exp agmsmith $
d303 3
@


1.6
log
@Work in progress adding fields and descriptions, worrying about deleting.
@
text
@d3 1
a3 1
<SMALL>$Id: Database\040Design.md,v 1.5 2020/01/30 22:16:28 agmsmith Exp agmsmith $</SMALL>
d67 1
a67 1
* creator_id Identifies the user who created this record.  Not NULL; the root
d71 3
a73 3
  settings list which contains the default permissions.  For
  discussion groups, it will point to the permission in the group's settings.
  Updated when a new permissions record is linked to this object.
d87 14
d112 5
a116 5
* killed_too boolean TRUE if the object is killed, false if it is merely
  deleted.  The difference is that all links to a killed object are marked
  deleted too, so the object will no longer be in lists.  The kill flag is
  ignored when deleting a LedgerDelete record - all associated LinkDelete
  records and objects are updated recursively.
d124 60
d195 1
a195 1
  can refer to the link record, really only used when deleting links.
d201 4
a204 3
* deleted_id Points to the LedgerUnlink or LedgerDelete record that deleted
  this record, otherwise NULL (this record is alive).  If this record is
  deleted, the link it made is considered to not exist any more.  Any rating
d209 15
d226 1
a226 1
: Marks an object as deleted, for use with LedgerDelete.  Parent is the
d230 9
a238 3
**LinkDelete** < LinkBase
: Marks a link as deleted.  Parent and child are the same as the object being
  deleted.  If this link object is deleted, then the child is undeleted.
d253 2
a254 1
categories. Second user navigates tree to see messages about their favourite topic.
d263 1
a263 1
$Header: /home/agmsmith/Programming/Rating\040Stone/docs/RCS/Database\040Design.md,v 1.5 2020/01/30 22:16:28 agmsmith Exp agmsmith $
d266 3
@


1.5
log
@Starting to add fields to the base object record.
@
text
@d3 1
a3 1
<SMALL>$Id: Database\040Design.md,v 1.4 2020/01/30 15:45:39 agmsmith Exp agmsmith $</SMALL>
d53 2
a54 1
using the actual database field names whenever we use the subclass object.
d56 4
a59 2
LedgerBase
: The base class for persistent objects that the user may interact with.
d66 1
d71 1
a71 1
  settings list which contains the default permissions, and other things.  For
d82 62
d166 1
a166 1
$Header: /home/agmsmith/Programming/Rating\040Stone/docs/RCS/Database\040Design.md,v 1.4 2020/01/30 15:45:39 agmsmith Exp agmsmith $
d169 3
@


1.4
log
@Explain the ledger write-once system and single table inheritance.
@
text
@d3 1
a3 1
<SMALL>$Id: Database\040Design.md,v 1.3 2020/01/30 14:40:09 agmsmith Exp agmsmith $</SMALL>
d52 2
a53 1
:email_address, :string2".
d56 1
a56 1
: The base class for persistent objects.
d58 40
a97 1
* First field name.
d100 1
a100 1
$Header: /home/agmsmith/Programming/Rating\040Stone/docs/RCS/Database\040Design.md,v 1.3 2020/01/30 14:40:09 agmsmith Exp agmsmith $
d103 3
@


1.3
log
@Writing continues, work in progress.
@
text
@d1 1
a1 1
# The Rating Stone Database
d3 1
a3 1
<SMALL>$Id: Database\040Design.md,v 1.2 2020/01/29 22:52:13 agmsmith Exp agmsmith $</SMALL>
d5 10
a14 3
Because I'm thinking someone could implement the system as a BlockChain ledger
application, or as a federated collection of systems exchanging records, the
database is set up as a mostly read-only collection of objects and linkages.
d18 18
a35 7
to the original text object.  Then when displaying the original text, it will
search for newer versions and display that text.  Of course, advanced users can
view a list of available versions of the text and see the change history.

Similarly when someone adds an item to a list, a link record will be added between the item object's id number and the list object's id number.  To remove an item, the link record isn't deleted, instead a new link kill record is created, with the same id number pair.

Theoretically, when displaying the current state of things, you run through all the records, adding and removing objects and links from the current state.  In practice, we cache things. So an object record would have a flag that marks it as deleted or amended, and a link record would similarly be marked.  Since people might want to reference a deleted thing, we don't actually delete them.
d38 2
a39 2
functionality for various related record types, we're using the Ruby on Rails
ActiveRecord "[single table
d41 12
a52 2
setup.  There will be one table, with a "type" field in each row to specify the
particular subclass used for that row.
d60 1
a60 1
$Header: /home/agmsmith/Programming/Rating\040Stone/docs/RCS/Database\040Design.md,v 1.2 2020/01/29 22:52:13 agmsmith Exp agmsmith $
d63 3
@


1.2
log
@Fixed up formatting of RCS log and version number.
@
text
@d3 1
a3 1
<SMALL>$Id: 1.1 $</SMALL>
d15 4
d32 1
a32 1
$Header: /home/agmsmith/Programming/Rating\040Stone/docs/RCS/Database\040Design.md,v 1.1 2020/01/29 22:43:07 agmsmith Exp agmsmith $
d35 2
@


1.1
log
@Initial revision
@
text
@d3 2
a4 1
$Revision$
d6 1
a6 1
application,  or as a federated collection of systems exchanging records, the
d9 12
a20 4
For example, if you want to edit some posted text, the system will create a later object (they all have datestamps) with the new text and a reference back to the original text object. Then when displaying the original text, it will search for newer versions and display that text.  Of course, advanced users can view a list of available versions of the text and see the change history.

Because I don't want to have zillions of tables, and want to inherit functionality for
various related record types, we're using the Ruby on Rails ActiveRecord "[single table inheritance](https://api.rubyonrails.org/classes/ActiveRecord/Inheritance.html)" setup.   There will be one table, with a "type" field in each row to specify the particular subclass used for that row.
d27 4
a30 2
$Header$
$Log$
d32 3
@
