head	1.5;
access;
symbols;
locks; strict;
comment	@# @;


1.5
date	2020.01.30.22.16.28;	author agmsmith;	state Exp;
branches;
next	1.4;

1.4
date	2020.01.30.15.45.39;	author agmsmith;	state Exp;
branches;
next	1.3;

1.3
date	2020.01.30.14.40.09;	author agmsmith;	state Exp;
branches;
next	1.2;

1.2
date	2020.01.29.22.52.13;	author agmsmith;	state Exp;
branches;
next	1.1;

1.1
date	2020.01.29.22.43.07;	author agmsmith;	state Exp;
branches;
next	;


desc
@Documenting the Rating Stone database design, and related classes.
@


1.5
log
@Starting to add fields to the base object record.
@
text
@# The Rating Stone Reputation System Database

<SMALL>$Id: Database\040Design.md,v 1.4 2020/01/30 15:45:39 agmsmith Exp agmsmith $</SMALL>

Because I'm thinking someone could implement the reputation system as a
BlockChain ledger application, or as a federated collection of systems
exchanging records, the database is set up as a write once collection of object
records and link records.  Objects are the things the user can view and they
have ratings (posted messages, lists of things, other users).  Links implement
lists of things, connecting a pair of objects together, one being a parent or
container object (such as a list of book reviews) and the other being a child
object now in that container (such as a book review object).  Usually rating
points are also transfered when you create a link (perhaps describing how much
you like that book review).

For example, if you want to edit some posted text, the system will create a
later object (they all have datestamps) with the new text and a reference back
to the original text object record.  Then when displaying the original text, it
will search for newer versions and display that text instead.  But new
references (links) to the text will still point at the original text record,
since that has a more constant identity then possibly yet more new text
records.  Of course, advanced users can view a list of all those text records
and see the change history.

Similarly when someone adds an item to a list, a link record will be added to
connect the list and the item.  To remove an item, the link record isn't
deleted, instead a new link kill record is created, referencing the same two
objects.

Theoretically, when displaying the current state of things, you run through all
the records in chronological order, adding and removing objects and links from
the current state.  In practice, we cache things.  So an object record would
have a flag that marks it as deleted or amended, and a link record would
similarly be marked, and there can be cached forward references to more quickly
point out the record with the latest change.

Because I don't want to have zillions of tables, and want to inherit
functionality for various related record types (generic object > text object >
book review object), we're using the Ruby on Rails ActiveRecord "[single table
inheritance](https://api.rubyonrails.org/classes/ActiveRecord/Inheritance.html)"
setup.  There will be one actual database table for objects and another one for
links, both have a "type" field in each row to specify the particular subclass
used for that row.

To avoid the common complaint about single table inheritance adding too many
fields for subclasses, we put some generic number and string fields into the
base class and reuse them differently for each subclass.  Subclasses give those
generic fields subclass-specific names by using the magic "alias_attribute"
ActiveRecord function.  So where the base may have a generic string1 and
string2 field, a User subclass could rename those as FullName and EMailAddress,
with "alias_attribute :full_name, :string1" and "alias_attribute
:email_address, :string2".  ActiveRecord will then automatically build queries
using the actual database field names whenever we use the subclass object.

LedgerBase
: The base class for persistent objects that the user may interact with.

* id The usual big (64 bit) integer unique record sequence number, which
  identifies the record/object.  There's an index of course to make finding a
  record by id number quick.  In the future we may use a GUID instead, or a
  pair of (id,server) if there are several federated servers run by different
  organisations.  Write-once.
* creator_id Identifies the user who created this record.  Not NULL; the root
  user is considered to have created themself.  Write-once.
* permissions_id Points to the most recent permissions record for this object.
  NULL if everybody is allowed to read it.  Often this will point to a user's
  settings list which contains the default permissions, and other things.  For
  discussion groups, it will point to the permission in the group's settings.
  Updated when a new permissions record is linked to this object.
* original_id Points to the original version of this record, or NULL if this is
  the original one.  When someone creates a link to the object, by default it's
  linked to by the original id.  The original record is still used to cache the
  rating points and other dyanmic things, though the actual content (text in a
  Post for example) comes from the latest amended record (unless the user is
  looking for a specific version the object).
* amended_id Points to the latest version of this record, or NULL if this is
  not the original record.

## Test Plan - A few Use Cases

A new user writes a message.  Another user replies to it.  First user edits
their message.  What does second user see?  First user replies to second user's
message.  First user deletes their original message.

A user adds some photos and videos to a message.  They are separate objects,
and need the expendature of rating points to be attached (more points are
required for a larger number of bytes).  What happens when they run out of
points?  Do they get attached to the message and show up when it is displayed?

First user sets up a small category tree and adds a message to a couple of
categories. Second user navigates tree to see messages about their favourite topic.

Weekly batch processing adds some reputation points to first and second user.
First user likes second user, awarding some up points, declaring their
appreciation.  Second user awards some down points to first user, declaring
their disgust.  What are their total points?  Another weekly batch run happens.
What are their points?

<PRE>
$Header: /home/agmsmith/Programming/Rating\040Stone/docs/RCS/Database\040Design.md,v 1.4 2020/01/30 15:45:39 agmsmith Exp agmsmith $

$Log: Database\040Design.md,v $
Revision 1.4  2020/01/30 15:45:39  agmsmith
Explain the ledger write-once system and single table inheritance.

Revision 1.3  2020/01/30 14:40:09  agmsmith
Writing continues, work in progress.

Revision 1.2  2020/01/29 22:52:13  agmsmith
Fixed up formatting of RCS log and version number.

Revision 1.1  2020/01/29 22:43:07  agmsmith
Initial revision
</PRE>
@


1.4
log
@Explain the ledger write-once system and single table inheritance.
@
text
@d3 1
a3 1
<SMALL>$Id: Database\040Design.md,v 1.3 2020/01/30 14:40:09 agmsmith Exp agmsmith $</SMALL>
d52 2
a53 1
:email_address, :string2".
d56 1
a56 1
: The base class for persistent objects.
d58 40
a97 1
* First field name.
d100 1
a100 1
$Header: /home/agmsmith/Programming/Rating\040Stone/docs/RCS/Database\040Design.md,v 1.3 2020/01/30 14:40:09 agmsmith Exp agmsmith $
d103 3
@


1.3
log
@Writing continues, work in progress.
@
text
@d1 1
a1 1
# The Rating Stone Database
d3 1
a3 1
<SMALL>$Id: Database\040Design.md,v 1.2 2020/01/29 22:52:13 agmsmith Exp agmsmith $</SMALL>
d5 10
a14 3
Because I'm thinking someone could implement the system as a BlockChain ledger
application, or as a federated collection of systems exchanging records, the
database is set up as a mostly read-only collection of objects and linkages.
d18 18
a35 7
to the original text object.  Then when displaying the original text, it will
search for newer versions and display that text.  Of course, advanced users can
view a list of available versions of the text and see the change history.

Similarly when someone adds an item to a list, a link record will be added between the item object's id number and the list object's id number.  To remove an item, the link record isn't deleted, instead a new link kill record is created, with the same id number pair.

Theoretically, when displaying the current state of things, you run through all the records, adding and removing objects and links from the current state.  In practice, we cache things. So an object record would have a flag that marks it as deleted or amended, and a link record would similarly be marked.  Since people might want to reference a deleted thing, we don't actually delete them.
d38 2
a39 2
functionality for various related record types, we're using the Ruby on Rails
ActiveRecord "[single table
d41 12
a52 2
setup.  There will be one table, with a "type" field in each row to specify the
particular subclass used for that row.
d60 1
a60 1
$Header: /home/agmsmith/Programming/Rating\040Stone/docs/RCS/Database\040Design.md,v 1.2 2020/01/29 22:52:13 agmsmith Exp agmsmith $
d63 3
@


1.2
log
@Fixed up formatting of RCS log and version number.
@
text
@d3 1
a3 1
<SMALL>$Id: 1.1 $</SMALL>
d15 4
d32 1
a32 1
$Header: /home/agmsmith/Programming/Rating\040Stone/docs/RCS/Database\040Design.md,v 1.1 2020/01/29 22:43:07 agmsmith Exp agmsmith $
d35 2
@


1.1
log
@Initial revision
@
text
@d3 2
a4 1
$Revision$
d6 1
a6 1
application,  or as a federated collection of systems exchanging records, the
d9 12
a20 4
For example, if you want to edit some posted text, the system will create a later object (they all have datestamps) with the new text and a reference back to the original text object. Then when displaying the original text, it will search for newer versions and display that text.  Of course, advanced users can view a list of available versions of the text and see the change history.

Because I don't want to have zillions of tables, and want to inherit functionality for
various related record types, we're using the Ruby on Rails ActiveRecord "[single table inheritance](https://api.rubyonrails.org/classes/ActiveRecord/Inheritance.html)" setup.   There will be one table, with a "type" field in each row to specify the particular subclass used for that row.
d27 4
a30 2
$Header$
$Log$
d32 3
@
